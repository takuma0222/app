# チャンバ状態チェック要件（ブラッシュアップ版 v2）

## 1. 前提整理

### 1.1 システム間の情報分布

| 情報 | App | MES（予約） | MES（着工指示） |
|------|-----|-------------|-----------------|
| 装置ID | ○ | ○ | ○ |
| カードNo | ○ | ○ | ○ |
| 前回レシピID | **○** | × | − |
| 前回使用ポート | **○** | × | − |
| 今回レシピID | × | × | **○** |
| 今回使用ポート（搬送レシピ） | × | × | **○** |

- App は装置ごとに **前回着工したレシピと使用ポート** を保持している。
- App→MES への予約は **装置 + カードNo** のみ（既存仕様）。
- MES の予約には搬送レシピ（使用チャンバ/ポート情報）が無い。
- **今回のレシピ・ポート情報は着工指示で初めて取得可能**。

### 1.2 追加要望

- 一部装置では、**特定レシピ（群）** について、
  前回の対象レシピ着工から **一定時間以内** に次の対象レシピを着工しなければ NG。
- 対象レシピ間に別レシピが挟まっても問題ない（介在許可）。
- ただし対象レシピ着工時だけは、直近の対象レシピ着工からの経過時間をチェックする。

---

## 2. 設計方針

### 2.1 App が持つ情報を最大活用する

App は「前回レシピ + 使用ポート」を既に保持しているため、
着工指示で「今回レシピ + 使用ポート」を受け取った時点で、
App 単体で以下の判定が完結する。

1. 今回レシピが時間制約対象グループに属するか
2. 前回の同グループレシピの着工時刻からの経過時間
3. ポート単位の制約がある場合、対象ポートの前回着工時刻

**MES への追加 IF 変更は不要。**

### 2.2 判定粒度 ― 装置単位 vs ポート単位

時間制約の粒度は装置によって異なりうるため、以下の2モードを設定可能とする。

| モード | 判定キー | ユースケース |
|--------|---------|-------------|
| 装置単位 | `equipment_id` + `recipe_group_id` | 装置全体で共有するプロセス条件の維持 |
| ポート単位 | `equipment_id` + `port_id` + `recipe_group_id` | チャンバ/ポートごとにコンディションが異なる場合 |

設定マスタの `scope` カラムで切り替える（後述）。

---

## 3. 業務ルール

### 3.1 判定タイミング

| フェーズ | 実施内容 | 判定可否 |
|---------|---------|---------|
| 予約登録（App→MES） | 装置 + カードNo を送信 | **最終判定不可**（今回レシピ不明） |
| ↳ 参考チェック | App が前回状態を参照し、対象グループの経過時間が閾値に近い場合に **警告ログ** を出力 | 参考のみ |
| 着工指示受信（MES→App） | 今回レシピ + ポート情報を取得 | **最終判定実施** |

### 3.2 着工時の判定ロジック

```
着工指示受信(equipment_id, card_no, recipe_id, port_ids[])
  │
  ├─ recipe_id → recipe_group_id を引き当て
  │   └─ 対象外 → ALLOW（制約なし）
  │
  ├─ scope を確認
  │   ├─ 装置単位 → key = (equipment_id, recipe_group_id)
  │   └─ ポート単位 → key = (equipment_id, port_id, recipe_group_id) ※各ポートで判定
  │
  ├─ key に対応する last_start_at を取得
  │   └─ 存在しない（初回） → ALLOW
  │
  ├─ delta_sec = now - last_start_at
  │   ├─ delta_sec <= max_interval_sec → ALLOW
  │   └─ delta_sec >  max_interval_sec → REJECT
  │
  └─ ALLOW の場合 → last_start_at = now に更新
     REJECT の場合 → ログ出力 + オペレータ通知
```

### 3.3 許可/拒否ルール

| 条件 | 結果 | 備考 |
|------|------|------|
| 対象グループ外のレシピ | ALLOW | タイマー更新なし |
| 対象グループ初回着工（前回実績なし） | ALLOW | タイマー起点を記録 |
| 経過時間 ≤ 閾値 | ALLOW | タイマー更新 |
| 経過時間 > 閾値 | REJECT | 理由コード付きで返却 |

理由コード:
- `TIME_WINDOW_EXCEEDED` — 経過時間超過
- `TIME_WINDOW_EXCEEDED_PORT` — ポート単位で経過時間超過

### 3.4 介在レシピの扱い

- 対象グループ外のレシピはいつでも着工可能。
- 介在中も対象グループのタイマーは経過し続ける。
- 介在レシピの着工・完了は `last_start_at` を更新しない。

```
例: レシピグループ A の制約 = 3600秒以内

  t=0     グループA着工 → last_start_at = 0    (ALLOW)
  t=600   グループB着工 →                       (ALLOW, タイマー無関係)
  t=1200  グループB着工 →                       (ALLOW, タイマー無関係)
  t=3000  グループA着工 → delta=3000 ≤ 3600    (ALLOW, last_start_at = 3000)
  t=7000  グループA着工 → delta=4000 > 3600    (REJECT)
```

---

## 4. データ設計（App側）

### 4.1 マスタ

#### `recipe_time_window_rule` — 時間制約ルール定義

| カラム | 型 | 説明 |
|--------|-----|------|
| `rule_id` | PK | ルールID |
| `equipment_id` | FK | 対象装置 |
| `recipe_group_id` | VARCHAR | 対象レシピグループ識別子 |
| `scope` | ENUM | `EQUIPMENT` / `PORT` |
| `max_interval_sec` | INT | 許容間隔（秒） |
| `enabled` | BOOL | 有効/無効 |
| `updated_at` | TIMESTAMP | 更新日時 |

#### `recipe_group_mapping` — レシピ→グループ紐付け

| カラム | 型 | 説明 |
|--------|-----|------|
| `recipe_group_id` | FK | レシピグループ |
| `recipe_id` | VARCHAR | 個別レシピID |

### 4.2 状態テーブル

#### `equipment_recipe_group_state` — 前回着工状態

| カラム | 型 | 説明 |
|--------|-----|------|
| `equipment_id` | FK | 装置 |
| `port_id` | VARCHAR / NULL | ポート（`scope=EQUIPMENT` の場合 NULL） |
| `recipe_group_id` | FK | レシピグループ |
| `last_recipe_id` | VARCHAR | 前回レシピID（App既存保持情報を流用） |
| `last_port_ids` | VARCHAR[] | 前回使用ポート一覧（App既存保持情報を流用） |
| `last_start_at` | TIMESTAMP | 前回着工時刻 |
| `last_card_no` | VARCHAR | 前回カードNo |
| `updated_at` | TIMESTAMP | 更新日時 |

> **ポイント**: App が既に保持している「前回レシピ」「使用ポート」をこのテーブルに集約。
> 既存の保持ロジックをそのまま利用し、着工時に `last_start_at` を追記記録する形で実装負荷を最小化。

### 4.3 ログテーブル

#### `start_judgement_log` — 判定履歴

| カラム | 型 | 説明 |
|--------|-----|------|
| `log_id` | PK | ログID |
| `equipment_id` | FK | 装置 |
| `port_id` | VARCHAR / NULL | 判定ポート |
| `card_no` | VARCHAR | カードNo |
| `recipe_id` | VARCHAR | 今回レシピ |
| `recipe_group_id` | VARCHAR / NULL | 対象グループ（非対象なら NULL） |
| `prev_recipe_id` | VARCHAR / NULL | 前回レシピ（App保持値） |
| `prev_port_ids` | VARCHAR[] / NULL | 前回使用ポート（App保持値） |
| `judgement` | ENUM | `ALLOW` / `REJECT` / `SKIP`（対象外） |
| `delta_sec` | INT / NULL | 経過秒数 |
| `threshold_sec` | INT / NULL | 閾値 |
| `reason_code` | VARCHAR / NULL | 拒否理由コード |
| `created_at` | TIMESTAMP | 判定日時 |

---

## 5. 処理フロー（改訂 v2）

### 5.1 予約フェーズ

```
1. App が予約要求を受信（装置 + カードNo）
2. [参考チェック] App は該装置の全有効ルールに対して
   last_start_at からの経過時間を確認
   → 閾値の80%超過 → 警告ログ出力（予約は通す）
3. App → MES へ予約登録（装置 + カードNo）
```

### 5.2 着工フェーズ

```
4. MES → App へ着工指示（装置, カードNo, レシピID, 使用ポート）
5. App がレシピ → グループを引き当て
6. 対象グループの場合:
   a. scope に応じた判定キーで last_start_at を取得
   b. delta_sec を算出
   c. 判定（ALLOW / REJECT）
7. 判定結果を返却
   - ALLOW:
     → last_start_at = now, last_recipe_id, last_port_ids を更新
     → 着工続行
   - REJECT:
     → 着工停止
     → 判定ログ出力
     → オペレータ通知（理由コード + 経過時間 + 閾値を表示）
8. 対象グループ外の場合:
   → ALLOW（タイマー更新なし）
   → 既存の前回レシピ/ポート更新は通常通り実施
```

---

## 6. 例外・運用考慮

| 項目 | 対応方針 |
|------|---------|
| **時刻同期** | App の内部時刻（NTP同期済み）を判定基準にする。MES/装置時刻は使用しない |
| **同時着工排他** | `equipment_recipe_group_state` の更新は装置単位で排他制御（楽観ロック or SELECT FOR UPDATE） |
| **App再起動** | 状態テーブルは永続化されているため復旧可能。インメモリキャッシュがある場合は起動時にDBからリロード |
| **一時解除** | ルールの `enabled` を OFF にする運用スイッチ。保全・立上げ時に使用 |
| **ポートメンテナンス** | ポート停止/復帰時に `last_start_at` をリセットするか保持するかは運用取り決め |
| **レシピ変更** | `recipe_group_mapping` を更新。状態テーブルの `last_start_at` はリセットしない（安全側） |

---

## 7. 仕様差分まとめ（v1→v2）

| 項目 | v1 | v2（今回） |
|------|-----|-----------|
| 前回レシピ情報 | 着工指示でのみ取得想定 | **App が既に保持**（前提修正） |
| 前回使用ポート | 未考慮 | **App が既に保持**（ポート粒度判定に活用） |
| 判定粒度 | 装置単位のみ | **装置単位 / ポート単位** を選択可能 |
| 予約時チェック | 参考警告のみ | 参考警告（閾値80%超過で警告ログ）を具体化 |
| MES IF変更 | 不要 | **不要**（変更なし） |
| ログ | 判定結果のみ | 前回レシピ/ポート情報もログに含める（トレーサビリティ向上） |

---

## 8. 未確定事項（確認依頼）

1. **制約粒度の既定値**: 「装置単位」と「ポート単位」のどちらをデフォルトとするか
2. **超過時の動作**: REJECT 固定か、HOLD（手動解除で着工再開）も必要か
3. **タイマー起点**: 「着工時刻」固定か、「完了時刻」を基準にするケースもあるか
4. **ポートメンテナンス後のタイマー**: リセットするか、経過時間を維持するか
5. **予約時の警告閾値**: 80%でよいか、別の値が適切か

上記が確定すれば、実装仕様（コード設計・DB DDL・エラーコード一覧）に進められます。