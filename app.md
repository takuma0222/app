# チャンバ状態チェック — 予約可否判定要件（v5）

## 1. システム構成と処理の流れ

### 1.1 システム一覧

| システム | 役割 |
|---------|------|
| **着工指示システム** | 次に着工すべきロットをオペレータに表示するだけのシステム |
| **App** | 機種ごとに存在する装置制御アプリケーション。装置ごとに個別カスタマイズあり。MES に対して「装置 + カードNo」で **予約送信** を行う |
| **MES** | 予約管理・ロット管理を担う上位システム。App からの予約を受信し、**内部の予約可否処理** で各種チェックを実施する。この予約可否処理の中で **レシピID を取得可能** |
| **装置** | 実際の処理を行う製造装置 |

### 1.2 処理の流れ（概要）

```
着工指示システム → オペレータに次ロットを表示
                    ↓
                  オペレータが着工操作
                    ↓
App ──── 予約送信（装置 + カードNo）────→ MES
                                           │
                                      ┌────┴─────┐
                                      │ 予約可否処理 │
                                      │（レシピID取得）│
                                      │  各種Check  │
                                      └────┬─────┘
                                           │
App ←──── 予約可否応答（OK / NG）──────── MES
  │
  │ OK の場合
  ├→ App → 装置へ着工指示
```

### 1.3 情報の分布と取得タイミング

| 情報 | App | MES（予約受信時） | MES（予約可否処理内） |
|------|-----|------------------|---------------------|
| 装置ID | ○ | ○ | ○ |
| カードNo | ○ | ○ | ○ |
| 今回レシピID | × | × | **○**（予約可否処理で取得） |
| 今回使用ポート | × | × | × ※搬送レシピはMES未保持 |
| 前回レシピID | **○** | × | △（App経由 or MES実績） |
| 前回使用ポート | **○** | × | △（App経由 or MES実績） |
| 前回完了時刻 | **○** | **○** | **○** |
| 処理中ポート | **○** | × | × |
| 残メンテナンス積算時間 | **○** | × | △（App API経由で取得可能） |
| レシピの想定処理時間 | × | × | × ※どこも未保持 |

**ポイント**:
- App → MES への予約送信は **装置 + カードNo のみ**（既存仕様、変更なし）
- MES は予約可否処理で **レシピID を内部で取得**できる
- 搬送レシピ（使用ポート情報）は MES にない
- 前回レシピ/ポート情報は App が保持（MES に渡す IF 追加が必要か、後述）

---

## 2. 要件一覧

MES 予約可否処理に組み込む判定チェックは以下の4つ：

| # | チェック名 | 概要 | 判定タイミング |
|---|-----------|------|--------------|
| C1 | **連続着工監視（スタンバイ時間チェック）** | 前回完了から一定時間以上スタンバイ（放置）していないか | MES 予約可否処理 |
| C2 | **ポート非連続チェック** | 前回使用ポートと今回使用ポートが異なる場合、非連続（コンディション断絶）とみなす | MES 予約可否処理 |
| C3 | **レシピ非連続チェック** | 前回レシピと今回レシピが異なり、かつ対象レシピ群に属する場合、実質非連続とみなす | MES 予約可否処理 |
| C4 | **積算時間超過チェック** | 残メンテナンス積算時間がX分のときに、X分以上かかる処理を投入するとメンテナンス超過するため拒否 | MES 予約可否処理 |

---

## 3. 各チェックの詳細

### 3.1 C1: 連続着工監視（スタンバイ時間チェック）

**目的**: 特定レシピ群において、前回完了後に一定時間以上放置されると装置コンディションが劣化するため、着工を禁止する。

**判定ロジック**:
```
予約可否処理(equipment_id, card_no)
  │
  ├─ レシピID を取得
  ├─ recipe_id → recipe_group_id を引き当て
  │   └─ 対象外 → PASS（チェック不要）
  │
  ├─ last_complete_at を取得（MES実績 or App問い合わせ）
  │   └─ 存在しない（初回） → OK
  │
  ├─ standby_sec = now - last_complete_at
  │   ├─ standby_sec <= max_standby_sec → OK（連続着工維持）
  │   └─ standby_sec >  max_standby_sec → NG（スタンバイ超過）
  │
  └─ OK → 次のチェックへ
     NG → 予約拒否（理由: STANDBY_TIME_EXCEEDED）
```

**介在レシピの扱い**:
- 対象レシピ群の間に別レシピが挟まっても **タイマーリセットはしない**
- タイマー起点は常に「対象レシピ群の前回完了時刻」
- 非対象レシピの着工・完了は `last_complete_at` を更新しない

```
例: レシピグループ A の閾値 = 3600秒

  t=0     グループA完了 → last_complete_at = 0
  t=300   グループB着工 →                         (対象外、タイマー無関係)
  t=900   グループB完了 →                         (タイマー更新なし)
  t=1000  グループA予約 → standby=1000 ≤ 3600     (OK)
  t=1600  グループA完了 → last_complete_at = 1600
  t=5700  グループA予約 → standby=4100 > 3600     (NG: スタンバイ超過)
```

---

### 3.2 C2: ポート非連続チェック

**目的**: 前回と異なるポートで処理する場合、チャンバのコンディションが断絶するため、そのまま連続着工とみなすことはできない。装置によってはダミーロットでの前処理が必要。

**判定ロジック**:
```
予約可否処理(equipment_id, card_no)
  │
  ├─ 今回使用ポートを取得
  │   └─ 取得不可（搬送レシピ未保持）
  │       → App API で処理中ポート/前回使用ポートを問い合わせ
  │       → or App が予約送信時に前回使用ポートを付加（IF拡張案 A）
  │
  ├─ 前回使用ポートを取得（App保持値）
  │
  ├─ 前回ポート == 今回ポート → OK（連続）
  ├─ 前回ポート != 今回ポート → NG（非連続: ポート変更）
  │   ├─ ダミーロット必要な装置 → NG + ダミーロット指示
  │   └─ ダミーロット不要な装置 → NG（コンディション断絶通知のみ）
  │
  └─ ポート情報取得不可 → 判定スキップ or 警告付きOK
```

**課題: 今回使用ポートの取得方法**

搬送レシピ（使用ポート情報）は MES が持っていないため、以下のいずれかで解決する必要がある：

| 案 | 方法 | 影響 |
|-----|------|------|
| A | App が予約送信時に「前回使用ポート」を付加する（IF拡張） | **MES予約IFに1項目追加** |
| B | MES が予約可否処理で App API を呼び出し、前回使用ポートを取得 | MES に API呼び出しロジック追加 |
| C | ポート非連続チェックは App 側で実施（MES では行わない） | App 個別カスタマイズ |

---

### 3.3 C3: レシピ非連続チェック

**目的**: 前回レシピと今回レシピが異なり、かつ特定のレシピ群に属する場合、チャンバコンディションの連続性が途切れるとみなす。

**判定ロジック**:
```
予約可否処理(equipment_id, card_no)
  │
  ├─ 今回レシピID を取得（MES内部で取得済み）
  ├─ 前回レシピID を取得（App保持値 → MES に連携要）
  │
  ├─ 今回/前回とも同一レシピグループか判定
  │   └─ どちらかが対象外 → PASS
  │
  ├─ 前回レシピ == 今回レシピ → OK（連続）
  ├─ 前回レシピ != 今回レシピ
  │   ├─ 同一グループ内の許容変更 → OK
  │   └─ グループが異なる or 許容外 → NG（実質非連続: レシピ変更）
  │
  └─ OK → 次のチェックへ
     NG → 予約拒否（理由: RECIPE_DISCONTINUITY）
```

**前回レシピIDの取得方法**:

| 案 | 方法 | 影響 |
|-----|------|------|
| A | App が予約送信時に「前回レシピID」を付加する（IF拡張） | **MES予約IFに1項目追加** |
| B | MES が予約可否処理で App API を呼び出し、前回レシピIDを取得 | MES に API呼び出しロジック追加 |
| C | MES 自身が前回実績レシピIDを保持（MES完了実績から取得） | MES 内部改修 |

---

### 3.4 C4: 積算時間超過チェック

**目的**: 装置のメンテナンスまでの残り積算時間がX分のとき、処理に想定X分以上かかるレシピを投入すると、処理途中でメンテナンス閾値を超過してしまう。これを事前に防止する。

**前提**:
- 残メンテナンス積算時間は **App が保持**（装置からリアルタイム取得 or App 内部計算）
- レシピの想定処理時間は **どのシステムも保持していない**（→ マスタ新設が必要）

**判定ロジック**:
```
予約可否処理(equipment_id, card_no)
  │
  ├─ 今回レシピID を取得
  ├─ 今回レシピの想定処理時間を取得（新設マスタから）
  │   └─ 取得不可 → チェックスキップ
  │
  ├─ 残メンテナンス積算時間を取得（App API 経由）
  │   └─ 取得不可 → チェックスキップ
  │
  ├─ remaining_maint_min = 残メンテナンス積算時間（分）
  ├─ recipe_duration_min = レシピ想定処理時間（分）
  │
  ├─ remaining_maint_min > recipe_duration_min → OK
  ├─ remaining_maint_min <= recipe_duration_min → NG（積算超過見込み）
  │   （※ マージンを設ける場合: remaining - margin > duration → OK）
  │
  └─ OK → 次のチェックへ
     NG → 予約拒否（理由: MAINTENANCE_TIME_EXCEEDED）
```

**レシピ想定処理時間のマスタ新設**:

| 案 | マスタ配置 | 説明 |
|-----|-----------|------|
| A | MES 側に新設 | MES の予約可否処理で直接参照可能。MES 管理者がメンテ |
| B | App 側に新設、API で MES に提供 | 装置ごとの差異を App 側で吸収 |

---

## 4. MES 予約可否処理の全体フロー

```
App → MES 予約送信（装置ID, カードNo [, 前回レシピID, 前回使用ポート ※IF拡張時]）
  │
  │ ── MES 予約可否処理開始 ──
  │
  ├─ レシピID を取得
  │
  ├─ [C1] 連続着工監視（スタンバイ時間チェック）
  │   └─ NG → 予約拒否（STANDBY_TIME_EXCEEDED）
  │
  ├─ [C2] ポート非連続チェック
  │   └─ NG → 予約拒否（PORT_DISCONTINUITY）
  │         → ダミーロット必要装置の場合、ダミーロット指示も付加
  │
  ├─ [C3] レシピ非連続チェック
  │   └─ NG → 予約拒否（RECIPE_DISCONTINUITY）
  │
  ├─ [C4] 積算時間超過チェック
  │   └─ NG → 予約拒否（MAINTENANCE_TIME_EXCEEDED）
  │
  ├─ 全チェック OK
  │
  │ ── MES 予約可否処理完了 ──
  │
  └─ MES → App 予約可否応答（OK / NG + 理由コード）
       │
       ├─ OK → App → 装置へ着工指示
       └─ NG → App がオペレータに理由表示 → 着工指示システムで次ロット選択へ
```

---

## 5. IF設計

### 5.1 既存IF（変更なし）

**App → MES 予約送信**（現行）:
```
装置ID, カードNo
```

### 5.2 IF拡張案（検討中）

**App → MES 予約送信**（拡張案）:
```
装置ID, カードNo, 前回レシピID, 前回使用ポート
```

> C2/C3 の判定で前回情報が必要。IF拡張するか、MES から App API を呼ぶかの2択。

### 5.3 App 提供 API（MES から呼び出し）

MES が予約可否処理で App の情報を参照するための API：

#### `GET /api/equipment/{equipment_id}/status`

**レスポンス**:
```json
{
  "equipment_id": "EQ001",
  "prev_recipe_id": "RECIPE_A",
  "prev_port_ids": ["PORT1"],
  "last_complete_at": "2026-02-16T10:30:00Z",
  "processing_ports": [
    { "port_id": "PORT1", "status": "IDLE" },
    { "port_id": "PORT2", "status": "PROCESSING", "card_no": "CARD123" }
  ],
  "remaining_maintenance_min": 45,
  "recipe_group_states": [
    {
      "recipe_group_id": "GROUP_A",
      "last_complete_at": "2026-02-16T10:30:00Z",
      "max_standby_sec": 3600,
      "elapsed_sec": 2400,
      "remaining_sec": 1200
    }
  ]
}
```

### 5.4 MES → App 予約可否応答

```json
{
  "equipment_id": "EQ001",
  "card_no": "CARD456",
  "result": "NG",
  "checks": [
    { "check": "C1", "result": "OK" },
    { "check": "C2", "result": "NG", "reason_code": "PORT_DISCONTINUITY",
      "detail": "前回ポート=PORT1, 今回ポート=PORT2",
      "dummy_lot_required": true },
    { "check": "C3", "result": "OK" },
    { "check": "C4", "result": "OK" }
  ]
}
```

---

## 6. データ設計

### 6.1 MES 側マスタ

#### `standby_rule` — 連続着工監視ルール（C1用）

| カラム | 型 | 説明 |
|--------|-----|------|
| `rule_id` | PK | ルールID |
| `equipment_id` | FK | 対象装置 |
| `recipe_group_id` | VARCHAR | 対象レシピグループ |
| `max_standby_sec` | INT | 最大スタンバイ許容時間（秒）※前回完了から |
| `enabled` | BOOL | 有効/無効 |

#### `recipe_group_mapping` — レシピ→グループ紐付け（C1/C3共用）

| カラム | 型 | 説明 |
|--------|-----|------|
| `recipe_group_id` | VARCHAR | レシピグループ |
| `recipe_id` | VARCHAR | 個別レシピID |

#### `recipe_continuity_rule` — レシピ連続性ルール（C3用）

| カラム | 型 | 説明 |
|--------|-----|------|
| `rule_id` | PK | ルールID |
| `equipment_id` | FK | 対象装置 |
| `recipe_group_id` | VARCHAR | 対象レシピグループ |
| `allow_within_group` | BOOL | 同一グループ内のレシピ変更を許容するか |
| `enabled` | BOOL | 有効/無効 |

#### `port_continuity_rule` — ポート連続性ルール（C2用）

| カラム | 型 | 説明 |
|--------|-----|------|
| `equipment_id` | PK | 対象装置 |
| `dummy_lot_required` | BOOL | ダミーロット処理が必要か |
| `dummy_recipe_id` | VARCHAR / NULL | ダミーロット用レシピID |
| `enabled` | BOOL | 有効/無効 |

#### `recipe_duration_master` — レシピ想定処理時間（C4用、**新設**）

| カラム | 型 | 説明 |
|--------|-----|------|
| `recipe_id` | PK | レシピID |
| `equipment_id` | FK | 装置（装置ごとに異なる場合） |
| `expected_duration_min` | INT | 想定処理時間（分） |
| `margin_min` | INT | マージン（分）※超過判定に余裕を持たせる |

### 6.2 MES 側ログ

#### `reservation_check_log` — 予約可否判定ログ

| カラム | 型 | 説明 |
|--------|-----|------|
| `log_id` | PK | ログID |
| `equipment_id` | FK | 装置 |
| `card_no` | VARCHAR | カードNo |
| `recipe_id` | VARCHAR | 今回レシピ |
| `prev_recipe_id` | VARCHAR / NULL | 前回レシピ |
| `prev_port_ids` | VARCHAR / NULL | 前回使用ポート |
| `c1_result` | ENUM | `OK` / `NG` / `SKIP` |
| `c1_standby_sec` | INT / NULL | スタンバイ経過秒数 |
| `c2_result` | ENUM | `OK` / `NG` / `SKIP` |
| `c2_dummy_lot` | BOOL | ダミーロット必要か |
| `c3_result` | ENUM | `OK` / `NG` / `SKIP` |
| `c4_result` | ENUM | `OK` / `NG` / `SKIP` |
| `c4_remaining_maint_min` | INT / NULL | 残積算時間 |
| `c4_recipe_duration_min` | INT / NULL | レシピ想定処理時間 |
| `overall_result` | ENUM | `OK` / `NG` |
| `reason_codes` | VARCHAR[] | NG理由コード一覧 |
| `created_at` | TIMESTAMP | 判定日時 |

### 6.3 App 側状態（既存活用）

App が既に保持している情報を、MES からの API 問い合わせに応じて提供する：

- 前回レシピID
- 前回使用ポート
- 前回完了時刻
- 処理中ポート状態
- 残メンテナンス積算時間（装置から取得 or App内部計算）
- レシピグループごとの最終完了時刻

---

## 7. 処理フロー（v5）

### 7.1 正常系（全チェック OK）

```
1. 着工指示システム → オペレータに次ロットを表示
2. オペレータが着工操作
3. App → MES へ予約送信（装置ID + カードNo）
4. MES: 予約可否処理開始
     a. レシピID を内部取得
     b. App API で装置状態を取得（前回レシピ/ポート/完了時刻/残積算時間）
     c. C1: スタンバイ時間チェック → OK
     d. C2: ポート非連続チェック → OK
     e. C3: レシピ非連続チェック → OK
     f. C4: 積算時間超過チェック → OK
     g. 判定ログ記録
5. MES → App 予約OK応答
6. App → 装置へ着工指示
```

### 7.2 異常系（C1 NG: スタンバイ超過）

```
4-c. C1: standby_sec = 4200 > max_standby_sec = 3600 → NG
5. MES → App 予約NG応答（STANDBY_TIME_EXCEEDED）
6. App → オペレータに表示「スタンバイ時間超過のため予約不可」
7. オペレータ → 着工指示システムで別のロット/装置を選択
```

### 7.3 異常系（C2 NG: ポート変更 + ダミーロット）

```
4-d. C2: 前回ポート=PORT1, 今回ポート=PORT2 → NG（ダミーロット必要）
5. MES → App 予約NG応答（PORT_DISCONTINUITY, dummy_lot_required=true）
6. App → ダミーロット自動投入（装置個別ロジック）
7. ダミーロット完了後、App → MES へ再予約送信
8. MES: 再度予約可否処理 → OK
9. App → 装置へ本ロットの着工指示
```

### 7.4 異常系（C4 NG: 積算時間超過見込み）

```
4-f. C4: remaining=30分, recipe_duration=45分 → NG（超過見込み）
5. MES → App 予約NG応答（MAINTENANCE_TIME_EXCEEDED）
6. App → オペレータに表示
     「残メンテナンス積算時間(30分)がレシピ処理時間(45分)を下回るため予約不可。
      メンテナンスを先に実施してください」
7. オペレータ → メンテナンス実施 or 別ロット選択
```

---

## 8. 例外・運用考慮

| 項目 | 対応方針 |
|------|---------|
| **App API タイムアウト** | MES が App API を呼び出せない場合、C2/C3/C4 はスキップし C1 のみ MES 内部実績で判定。予約は警告付きで OK |
| **レシピ処理時間マスタ未登録** | C4 はスキップ（安全側で OK）。マスタ未登録アラートをログ出力 |
| **ダミーロット失敗** | ダミーロット処理が失敗した場合、本来のロットは着工不可。オペレータ通知 |
| **同時予約排他** | MES 予約可否処理は装置単位で排他制御（同一装置への同時予約要求をシリアライズ） |
| **一時解除** | 各ルールの `enabled` を OFF にする運用スイッチ。保全・立上げ時に使用 |
| **メンテナンス後のリセット** | メンテナンス完了時に残積算時間をリセット。C1 の `last_complete_at` もリセット |
| **異常完了時** | 処理が異常終了した場合、完了時刻を記録するかリセットするかは運用取り決め |

---

## 9. 仕様差分まとめ（v4→v5）

| 項目 | v4 | v5（今回） |
|------|-----|-----------|
| チェックの実施場所 | App（最終判定）/ MES（参考警告） | **MES 予約可否処理**（メイン判定場所を MES に一元化） |
| レシピID取得 | App で推定 or MES問い合わせ | **MES 予約可否処理内で取得**（既存仕様） |
| 着工指示システム | 未言及 | **明記**（ロット表示のみの役割） |
| チェック体系 | R1〜R4 | **C1〜C4 に再整理**（連続着工監視/ポート非連続/レシピ非連続/積算時間超過） |
| 積算時間超過チェック | 処理時間マスタなしで実現不可 | **レシピ処理時間マスタ新設** で実現 |
| ダミーロット | App 個別処理 | MES 判定結果を受けて **App が自動投入後に再予約** |
| 予約IF | 装置+カードNo のみ | 同左（**拡張案として前回レシピ/ポート付加を検討**） |

---

## 10. 決定が必要な事項

| # | 項目 | 選択肢 | 推奨 |
|---|------|-------|------|
| D1 | **前回レシピ/ポートの取得方法** | A: App予約IFに追加 / B: MES→App API呼び出し / C: MES内部実績活用 | **A**（IF変更最小、MES側API依存なし） |
| D2 | **レシピ処理時間マスタの配置** | A: MES側 / B: App側（API提供） | **A**（MES予約可否処理で直接参照） |
| D3 | **C4の積算時間取得方法** | A: App API経由 / B: MES側でも積算管理 | **A**（App既存情報の活用） |
| D4 | **ダミーロット投入フロー** | A: App自動投入→再予約 / B: オペレータ手動投入 / C: 装置ごとに選択 | **C** |
| D5 | **C2のNG時の動作** | A: NG返却のみ / B: NG + ダミーロット必要フラグ返却 / C: MESからダミーロット予約まで実施 | **B** |
| D6 | **各チェックの独立有効/無効** | 装置ごとに C1〜C4 を個別に ON/OFF できるか | **YES**（装置個別カスタマイズ対応） |

上記 D1〜D6 が確定すれば、詳細 IF 仕様・DB DDL・シーケンス図に進められます。
